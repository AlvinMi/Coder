4.8.6.运算中的临时匿名变量
4.8.6.1、C语言和汇编的区别（汇编完全对应机器操作，C对应逻辑操作）
(1)C语言叫高级语言，汇编语言叫低级语言。
(2)低级语言的意思是汇编语言和机器操作相对应，汇编语言只是CPU的机器码的助记符，用汇编语言写程序必须拥有机器的思维。因为不同的CPU设计时指令集差异很大，因此用汇编编程的差异很大。
(3)高级语言（C语言）它对低级语言进行了封装（C语言的编译器来完成），给程序员提供了一个靠近人类思维的一些语法特征，人类不用过于考虑机器原理，而可以按照自己的逻辑原理来编程。譬如数组、结构体、指针・・・・
(4)更高级的语言如java、C#等只是进一步强化了C语言提供的人性化的操作界面语法，在易用性上、安全性上进行了提升。

4.8.6.2、C语言的一些“小动作”
(1)高级语言中有一些元素是机器中没有的
(2)高级语言在运算中允许我们大跨度的运算。意思就是低级语言中需要好几步才能完成的一个运算，在高级语言中只要一步即可完成。譬如C语言中一个变量i要加1，在C中只需要i++即可，看起来只有一句代码。但实际上翻译到汇编阶段需要3步才能完成：第1步从内存中读取i到寄存器，第2步对寄存器中的i进行加1，第3步将加1后的i写回内存中的i。

4.8.6.3、使用临时变量来理解强制类型转换

4.8.6.4、使用临时变量来理解不同数据类型之间的运算


4.8.7.顺序结构
4.8.7.1、最浅显的顺序结构：三种结构之一
(1)代码执行的时候如果没有遇到判断跳转或者循环，默认是顺序执行的。执行完上一句则开始执行下一句。
(2)顺序结构说明CPU的工作状态，就是以时间轴来顺序执行所有的代码语句直到停机。

4.8.7.2、选择和循环结构内部的顺序结构
(1)譬如if(){}在{}内部是if的代码段，在代码段内部还是按照顺序结构来执行的。
(2)switch case内部也一样，也是按照顺序结构执行的。
(3)while for内部也是按照顺序结构来执行的。

4.8.7.3、编译过程中的顺序结构
(1)一个C程序有多个.c文件组成，编译的时候多个.c文件是独立分开编译的。每个c文件编译的时候，编译器是按照从前到后的顺序逐行进行编译的。
(2)编译器编程时的顺序编译会导致函数/变量必须先定义/声明才能调用，这也是C语言中函数/变量声明的来源。
(3)链接过程中呢？应该说链接过程链接器实际上是在链接脚本指导下完成的。所以链接时的.o文件的顺序是由链接脚本指定的。如果链接脚本中明确指定了顺序则会优先考虑这个规则按照这个指定的顺序排布，如果链接脚本中没有指定具体的顺序则链接器会自动的排布。

4.8.7.4、思考：为什么本质都是顺序结构？
(1)顺序结构本质上符号CPU的设计原理，CPU又是人设计的，所以CPU的设计符合人的思考原理


4.8.8.程序调试的debug宏
4.8.8.1、程序调试的常见方案：单步调试、裸机LED调试、打印信息、log文件
(1)利用调试器进行单步调试（譬如IDE中，Jlink）适用于新手，最大的好处就是直观，能够帮助找到问题。缺点是限制性大、速度慢。
(2)裸机使用LED、蜂鸣器等硬件调试，适合单片机裸机程序
(3)printf函数打印调试，比较常用，作为程序员必须学会使用打印信息调试。好处是具有普遍性，几乎在所有的情况下都能用。
(4)log文件（日志文件）是系统运行过程中在特定时候会打印一些调试信息，日志文件记录下来这些调试信息以供后续查找追查问题。适合于系统级或者大型程序的调试。

4.8.8.2、打印信息不能太多也不能太少
(1)调试信息太少会不够信息找到问题所在。
(2)调试信息太多会有大量的无用的信息淹没有用信息，导致有用信息无法看见，等于没有。

4.8.8.3、调试(DEBUG)版本和发行(RELEASE)版本的区别
(1)DEBUG版本就是包含了调试信息输出的版本，在程序测试过程中会发布debug版本，这种版本的程序运行时会打印出来调试信息/log文件，这些信息可以辅助测试人员判断程序的问题所在。DEBUG版本的坏处是输出调试信息占用了系统资源，拖慢了系统运行速度。因此DEBUG版本的性能低于RELEASE版本。
(2)RELEASE版本就是最终的发布版本，相较于DEBUG版本的功能代码是一样的，但是去掉了所有的调试信息。适合最终测试通过要发布的程序，因为去掉了调试信息所以程序的运行效率要更高。
(3)DEBUG和RELASE版本其实是一套源代码。源代码中是有很多的打印调试信息的语句的，如何来控制生成DEBUG和RELEEASE版本？靠条件编译，靠一个宏。

4.8.8.4、debug宏的实现原理
(1)DEBUG宏大概的原理是：
#ifdef DEBUG
#define dbg()		printf()
#else
#define dbg()	
#endif
(2)工作方式是：如果我们要输出DEBUG版本则在条件编译语句前加上#define DEBUG即可，这样程序中的调试语句dbg()就会被替换成printf从而输出；如果我们要输出RELEASE版本则去掉#define DEBUG，则dbg()就会被替换成空，则程序中所有的dbg()语句直接蒸发了，这样的程序编译时就会生成没有任何调试信息的代码。

4.8.8.5、debug宏的使用方法

4.5.8.6、分析几个DEBUG宏
(1)应用程序中DEBUG宏
#ifdef DEBUG
#define DBG(...) fprintf(stderr, " DBG(%s, %s(), %d): ", __FILE__, __FUNCTION__, __LINE__); fprintf(stderr, __VA_ARGS__)
#else
#define DBG(...)
#endif

注：__FILE__等是C语言中的预定义宏，就是说这个东西是个宏定义，但是是C语言自己定义的。这些宏具有特殊的含义，譬如__FILE__表示当前正在编译的c文件的文件名。

(2)内核中的DEBUG宏
#ifdef DEBUG_S3C_MEM
#define DEBUG(fmt, args...) 	printk(fmt, ##args)
#else
#define DEBUG(fmt, args...) 	do {} while (0)
#endif
































