

第一部分、章节目录
4.3.1.指针到底是什么？
4.3.2.指针带来的一些符号的理解
4.3.3.野指针问题
4.3.4.const关键字与指针
4.3.5.深入学习一下数组
4.3.6.指针与数组的天生姻缘
4.3.7.指针与强制类型转换
4.3.8.指针、数组与sizeof运算符
4.3.9.指针与函数传参
4.3.10.输入型参数与输出型参数

4.3.4.const关键字与指针
4.3.4.1、const修饰指针的4种形式
(1)const关键字，在C语言中用来修饰变量，表示这个变量是常量。
(2)const修饰指针有4种形式，区分清楚这4种即可全部理解const和指针。
	第一种：const int *p;
	第二种：int const *p;
	第三种：int * const p;
	第四种：const int * const p;
(3)关于指针变量的理解，主要涉及到2个变量：第一个是指针变量p本身，第二个是p指向的那个变量(*p)。一个const关键字只能修饰一个变量，所以弄清楚这4个表达式的关键就是搞清楚const放在某个位置是修饰谁的

4.3.4.2、const修饰的变量真的不能改吗？
(1)课堂练习说明：const修饰的变量其实是可以改的（前提是gcc环境下）。
(2)在某些单片机环境下，const修饰的变量是不可以改的。const修饰的变量到底能不能真的被修改，取决于具体的环境，C语言本身并没有完全严格一致的要求。
(3)在gcc中，const是通过编译器在编译的时候执行检查来确保实现的（也就是说const类型的变量不能改是编译错误，不是运行时错误。）所以我们只要想办法骗过编译器，就可以修改const定义的常量，而运行时不会报错。
(4)更深入一层的原因，是因为gcc把const类型的常量也放在了data段，其实和普通的全局变量放在data段是一样实现的，只是通过编译器认定这个变量是const的，运行时并没有标记const标志，所以只要骗过编译器就可以修改了。

4.3.4.3、const究竟应该怎么用
(1)const是在编译器中实现的，编译时检查，并非不能骗过。所以在C语言中使用const，就好象是 一种道德约束而非法律约束，所以大家使用const时更多是传递一种信息，就是告诉编译器、也告诉读程序的人，这个变量是不应该也不必被修改的。


4.3.5.深入学习一下数组
4.3.5.1、从内存角度来理解数组
(1)从内存角度讲，数组变量就是一次分配多个变量，而且这多个变量在内存中的存储单元是依次相连接的。
(2)我们分开定义多个变量（譬如int a, b, c, d;）和一次定义一个数组（int a[4]）；这两种定义方法相同点是都定义了4个int型变量，而且这4个变量都是独立的单个使用的；不同点是单独定义时a、b、c、d在内存中的地址不一定相连，但是定义成数组后，数组中的4个元素地址肯定是依次相连的。
(3)数组中多个变量虽然必须单独访问，但是因为他们的地址彼此相连，因此很适合用指针来操作，因此数组和指针天生就叫纠结在一起。

4.3.5.2、从编译器角度来理解数组
(1)从编译器角度来讲，数组变量也是变量，和普通变量和指针变量并没有本质不同。变量的本质就是一个地址，这个地址在编译器中决定具体数值，具体数值和变量名绑定，变量类型决定这个地址的延续长度。
(2)搞清楚：变量、变量名、变量类型这三个概念的具体含义，很多问题都清楚了。
int a;  char a;

4.3.5.3、数组中几个关键符号（a a[0] &a &a[0]）的理解（前提是 int a[10]）
(1)这4个符号搞清楚了，数组相关的很多问题都有答案了。理解这些符号的时候要和左值右值结合起来，也就是搞清楚每个符号分别做左值和右值时的不同含义。
(2)a就是数组名。a做左值时表示整个数组的所有空间（10×4=40字节），又因为C语言规定数组操作时要独立单个操作，不能整体操作数组，所以a不能做左值；a做右值表示数组首元素（数组的第0个元素，也就是a[0]）的首地址（首地址就是起始地址，就是4个字节中最开始第一个字节的地址）。a做右值等同于&a[0];
(2)a[0]表示数组的首元素，也就是数组的第0个元素。做左值时表示数组第0个元素对应的内存空间（连续4字节）；做右值时表示数组第0个元素的值（也就是数组第0个元素对应的内存空间中存储的那个数）
(3)&a就是数组名a取地址，字面意思来看就应该是数组的地址。&a不能做左值（&a实质是一个常量，不是变量因此不能赋值，所以自然不能做左值。）；&a做右值时表示整个数组的首地址。
(4)&a[0]字面意思就是数组第0个元素的首地址（搞清楚[]和&的优先级，[]的优先级要高于&，所以a先和[]结合再取地址）。做左值时表示数组首元素对应的内存空间，做右值时表示数组首元素的值（也就是数组首元素对应的内存空间中存储的那个数值）。做右值时&a[0]等同于a。

解释：为什么数组的地址是常量？因为数组是编译器在内存中自动分配的。当我们每次执行程序时，运行时都会帮我们分配一块内存给这个数组，只要完成了分配，这个数组的地址就定好了，本次程序运行直到终止都无法再改了。那么我们在程序中只能通过&a来获取这个分配的地址，却不能去用赋值运算符修改它。

总结：
1：&a和a做右值时的区别：&a是整个数组的首地址，而a是数组首元素的首地址。这两个在数字上是相等的，但是意义不相同。意义不相同会导致他们在参与运算的时候有不同的表现。
2：a和&a[0]做右值时意义和数值完全相同，完全可以互相替代。
3：&a是常量，不能做左值。
4：a做左值代表整个数组所有空间，所以a不能做左值。

4.3.6.指针与数组的天生姻缘
4.3.6.1、以指针方式来访问数组元素
(1)数组元素使用时不能整体访问，只能单个访问。访问方式有2种：数组形式和指针形式。
(2)数组格式访问数组元素是：数组名[下标]; (注意下标从0开始)
(3)指针格式访问数组元素是：*(指针+偏移量); 如果指针是数组首元素地址（a或者&a[0]），那么偏移量就是下标；指针也可以不是首元素地址而是其他哪个元素的地址，这时候偏移量就要考虑叠加了。
(4)数组下标方式和指针方式均可以访问数组元素，两者的实质其实是一样的。在编译器内部都是用指针方式来访问数组元素的，数组下标方式只是编译器提供给编程者一种壳（语法糖）而已。所以用指针方式来访问数组才是本质的做法。

4.3.6.2、从内存角度理解指针访问数组的实质
(1)数组的特点就是：数组中各个元素的地址是依次相连的，而且数组还有一个很大的特点（其实也是数组的一个限制）就是数组中各个元素的类型比较相同。类型相同就决定了每个数组元素占几个字节是相同的（譬如int数组每个元素都占4字节，没有例外）。
(2)数组中的元素其实就是地址相连接、占地大小相同的一串内存空间。这两个特点就决定了只要知道数组中一个元素的地址，就可以很容易推算出其他元素的地址。

4.3.6.3、指针和数组类型的匹配问题
(1)int *p; int a[5];	p = a;		// 类型匹配
(1)int *p; int a[5];	p = &a;		// 类型不匹配。p是int *，&a是整个数组的指针，也就是一个数组指针类型，不是int指针类型，所以不匹配
(2)&a、a、&a[0]从数值上来看是完全相等的，但是意义来看就不同了。从意义上来看，a和&a[0]是数组首元素首地址，而&a是整个数组的首地址；从类型来看，a和&a[0]是元素的指针，也就是int *类型；而&a是数组指针，是int (*)[5];类型。

4.3.6.4、总结：指针类型决定了指针如何参与运算
(1)指针参与运算时，因为指针变量本身存储的数值是表示地址的，所以运算也是地址的运算。
(2)指针参与运算的特点是，指针变量+1，并不是真的加1，而是加1*sizeof(指针类型)；如果是int *指针，则+1就实际表示地址+4，如果是char *指针，则+1就表示地址+1；如果是double *指针，则+1就表示地址+8.
(2)指针变量+1时实际不是加1而是加1×sizeof(指针类型)，主要原因是希望指针+1后刚好指向下一个元素（而不希望错位）。


4.3.7.指针与强制类型转换
4.3.7.1、变量的数据类型的含义
(1)所有的类型的数据存储在内存中，都是按照二进制格式存储的。所以内存中只知道有0和1，不知道是int的、还是float的还是其他类型。
(2)int、char、short等属于整形，他们的存储方式（数转换成二进制往内存中放的方式）是相同的，只是内存格子大小不同（所以这几种整形就彼此叫二进制兼容格式）；而float和double的存储方式彼此不同，和整形更不同。
(3)int a = 5;时，编译器给a分配4字节空间，并且将5按照int类型的存储方式转成二进制存到a所对应的内存空间中去（a做左值的）；我们printf去打印a的时候（a此时做右值），printf内部的vsprintf函数会按照格式化字符串（就是printf传参的第一个字符串参数中的%d之类的东西）所代表的类型去解析a所对应的内存空间，解析出的值用来输出。也就是说，存进去时是按照这个变量本身的数据类型来存储的（譬如本例中a为int所以按照int格式来存储）；但是取出来时是按照printf中%d之类的格式化字符串的格式来提取的。此时虽然a所代表的内存空间中的10101序列并没有变（内存是没被修改的）但是怎么理解（怎么把这些1010转成数字）就不一定了。譬如我们用%d来解析，那么还是按照int格式解析则值自然还是5；但是如果用%f来解析，则printf就以为a对应的内存空间中存储的是一个float类型的数，会按照float类型来解析，值自然是很奇怪的一个数字了。
总结：C语言中的数据类型的本质，就是决定了这个数在内存中怎么存储的问题，也就是决定了这个数如何转成二进制的问题。一定要记住的一点是内存只是存储1010的序列，而不管这些1010怎么解析。所以要求我们平时数据类型不能瞎胡乱搞。
分析几个题目：
* 按照int类型存却按照float类型取	一定会出错
* 按照int类型存却按照char类型取		有可能出错也有可能不出错
* 按照short类型存却按照int类型取	有可能出错也有可能不出错
* 按照float类型存却按照double取		一定会出错

4.3.7.2、指针的数据类型的含义
(1)指针的本质是：变量，指针就是指针变量
(2)一个指针涉及2个变量：一个是指针变量自己本身，一个是指针变量指向的那个变量
(3)int *p;定义指针变量时，p（指针变量本身）是int *类型，*p（指针指向的那个变量）是int类型的。
(4)int *类型说白了就是指针类型，只要是指针类型就都是占4字节，解析方式都是按照地址的方式来解析（意思是里面存的32个二进制加起来表示一个内存地址）的。结论就是：所有的指针类型（不管是int * 还是char * 还是double *）的解析方式是相同的，都是地址。
(5)对于指针所指向的那个变量来说，指针的类型就很重要了。指针所指向的那个变量的类型（它所对应的内存空间的解析方法）要取决于指针类型。譬如指针是int *的，那么指针所指向的变量就是int类型的。

4.3.7.3、指针数据类型转换实例分析1（int * -> char *）
(1)int和char类型都是整形，类型兼容的。所以互转的时候有时候错有时候对。
(2)int和char的不同在于char只有1个字节而int有4个字节，所以int的范围比char大。在char所表示的范围之内int和char是可以互转的不会出错；但是超过了char的范围后char转成int不会错（向大方向转就不会错，就好比拿小瓶子的水往大瓶子倒不会漏掉不会丢掉），而从int到char转就会出错（就好象拿大瓶子水往小瓶子倒一样）

4.3.7.4、指针数据类型转换实例分析2（int * -> float *）
(1)之前分析过：int和float的解析方式是不兼容的，所以int *转成float *再去访问绝对会出错。


4.3.8.指针、数组与sizeof运算符
(1)sizeof是C语言的一个运算符（主要sizeof不是函数，虽然用法很像函数），sizeof的作用是用来返回()里面的变量或者数据类型占用的内存字节数。
(2)sizeof存在的价值？主要是因为在不同平台下各种数据类型所占的内存字节数不尽相同（譬如int在32位系统中为4字节，在16位系统中为2字节・・・）。所以程序中需要使用sizeof来判断当前变量/数据类型在当前环境下占几个字节。
4.3.8.1、char str[] = ”hello”;  sizeof(str)	sizeof(str[0])	strlen(str)
4.3.8.2、char *p=str;  			sizeof(p)	sizeof(*p)	strlen(p)
(1)32位系统中所有指针的长度都是4，不管是什么类型的指针。
(2)strlen是一个C库函数，用来返回一个字符串的长度（注意，字符串的长度是不计算字符串末尾的'\0'的）。一定要注意strlen接收的参数必须是一个字符串（字符串的特征是以'\0'结尾）
4.3.8.3、int n=10; 				sizeof(n)
(1)sizeof测试一个变量本身，和sizeof测试这个变量的类型，结果是一样的。
4.3.8.4、int b[100];			sizeof(b)
(1)sizeof(数组名)的时候，数组名不做左值也不做右值，纯粹就是数组名的含义。那么sizeof(数组名)实际返回的是整个数组所占用内存空间（以字节为单位的）。
4.3.8.5、
		void fun(int b[100])
		{
								sizeof(b)
		}
(1)函数传参，形参是可以用数组的
(2)函数形参是数组时，实际传递是不是整个数组，而是数组的首元素首地址。也就是说函数传参用数组来传，实际相当于传递的是指针（指针指向数组的首元素首地址）。

4.3.8.6、
		#define dpChar char *
		typedef char *tpChar;

		dpChar p1,  p2;			sizeof(p1)	sizeof(p2)
		tpChar p3,  p4;			sizeof(p3)	sizeof(p4)

4.3.9.指针与函数传参
4.3.9.1、普通变量作为函数形参
(1)函数传参时，普通变量作为参数时，形参和实参名字可以相同也可以不同，实际上都是用实参来替代相对应的形参的。
(2)在子函数内部，形参的值等于实参。原因是函数调用时把实参的值赋值给了形参。
(3)这就是很多书上写的“传值调用”（相当于实参做右值，形参做左值）

4.3.9.2、数组作为函数形参
(1)函数名作为形参传参时，实际传递是不是整个数组，而是数组的首元素的首地址（也就是整个数组的首地址。因为传参时是传值，所以这两个没区别）。所以在子函数内部，传进来的数组名就等于是一个指向数组首元素首地址的指针。所以sizeof得到的是4.
(2)在子函数内传参得到的数组首元素首地址，和外面得到的数组首元素首地址的值是相同的。很多人把这种特性叫做“传址调用”（所谓的传址调用就是调用子函数时传了地址（也就是指针），此时可以通过传进去的地址来访问实参。）
(3)数组作为函数形参时，[]里的数字是可有可无的。为什么？因为数组名做形参传递的实际只是个指针，根本没有数组长度这个信息。

4.3.9.3、指针作为函数形参
(1)只有一句话：和数组作为函数形参是一样的.这就好像指针方式访问数组元素和数组方式访问数组元素的结果一样是一样的。

4.3.9.4、结构体变量作为函数形参
(1)结构体变量作为函数形参的时候，实际上和普通变量（类似于int之类的）传参时表现是一模一样的。所以说结构体变量其实也是普通变量而已。
(2)因为结构体一般都很大，所以如果直接用结构体变量进行传参，那么函数调用效率就会很低。（因为在函数传参的时候需要将实参赋值给形参，所以当传参的变量越大调用效率就会越低）。怎么解决？思路只有一个那就是不要传变量了，改传变量的指针（地址）进去。
(3)结构体因为自身太大，所以传参应该用指针来传（但是程序员可以自己决定，你非要传结构体变量过去C语言也是允许的，只是效率低了）；回想一下数组，为什么C语言设计的时候数组传参默认是传的数组首元素首地址而不是整个数组？

4.3.9.4、传值调用与传址调用
(1)传值调用描述的是这样一种现象：x和y作为实参，自己并没有真身进入swap1函数内部，而只是拷贝了一份自己的副本（副本具有和自己一样的值，但是是不同的变量）进入子函数swap1，然后我们在子函数swap1中交换的实际是副本而不是x、y真身。所以在swap1内部确实是交换了，但是到外部的x和y根本没有受影响。

(2)在swap2中x和y真的被改变了（但是x和y真身还是没有进入swap2函数内，而是swap2函数内部跑出来把外面的x和y真身改了）。实际上实参x和y永远无法真身进入子函数内部（进去的只能是一份拷贝），但是在swap2我们把x和y的地址传进去给子函数了，于是乎在子函数内可以通过指针解引用方式从函数内部访问到外部的x和y真身，从而改变x和y。
(3)结论：这个世界上根本没有传值和传址这两种方式，C语言本身函数调用时一直是传值的，只不过传的值可以是变量名，也可以是变量的指针。

4.3.10.输入型参数与输出型参数
4.3.10.1、函数为什么需要形参与返回值
(1)函数名是一个符号，表示整个函数代码段的首地址，实质是一个指针常量，所以在程序中使用到函数名时都是当地址用的，用来调用这个函数的。
(2)函数体是函数的关键，由一对{}括起来，包含很多句代码，函数体就是函数实际做的工作。
(3)形参列表和返回值。形参是函数的输入部分，返回值是函数的输出部分。对函数最好的理解就是把函数看成是一个加工机器（程序其实就是数据加工器），形参列表就是这个机器的原材料输入端；而返回值就是机器的成品输出端。
(4)其实如果没有形参列表和返回值，函数也能对数据进行加工，用全局变量即可。用全局变量来传参和用函数参数列表返回值来传参各有特点，在实践中都有使用。总的来说，函数参数传参用的比较多，因为这样可以实现模块化编程，而C语言中也是尽量减少使用全局变量。
(5)全局变量传参最大的好处就是省略了函数传参的开销，所以效率要高一些；但是实战中用的最多的还是传参，如果参数很多传参开销非常大，通常的做法是把很多参数打包成一个结构体，然后传结构体变量指针进去。

4.3.10.2、函数传参中使用const指针
(1)const一般用在函数参数列表中，用法是const int *p;（意义是指针变量p本身可变的，而p所指向的变量是不可变的）。
(2)const用来修饰指针做函数传参，作用就在于声明在函数内部不会改变这个指针所指向的内容，所以给该函数传一个不可改变的指针（char *p = "linux";这种）不会触发错误；而一个未声明为const的指针的函数，你给他传一个不可更改的指针的时候就要小心了。

4.3.10.3、函数需要向外部返回多个值时怎么办？
(1)一般来说，函数的收入部分就是函数参数，输出部分就是返回值。问题是函数的参数可以有很多个，而返回值只能有1个。这就造成我们无法让一个函数返回多个值。
(2)现实编程中，一个函数需要返回多个值是非常普遍的，因此完全依赖于返回值是不靠谱的，通常的做法是用参数来做返回（在典型的linux风格函数中，返回值是不用来返回结果的，而是用来返回0或者负数用来表示程序执行结果是对还是错，是成功还是失败）。
(3)普遍做法，编程中函数的输入和输出都是靠函数参数的，返回值只是用来表示函数执行的结果是对（成功）还是错（失败）。如果这个参数是用来做输入的，就叫输入型参数；如果这个参数的目的是用来做输出的，就叫输出型参数。
(4)输出型参数就是用来让函数内部把数据输出到函数外部的。

4.3.10.4、总结
(1)看到一个函数的原型后，怎么样一眼看出来哪个参数做输入哪个做输出？函数传参如果传的是普通变量（不是指针）那肯定是输入型参数；如果传指针就有2种可能性了，为了区别，经常的做法是：如果这个参数是做输入的（通常做输入的在函数内部只需要读取这个参数而不会需要更改它）就在指针前面加const来修饰；如果函数形参是指针变量并且还没加const，那么就表示这个参数是用来做输出型参数的。
譬如C库函数中strcpy函数
