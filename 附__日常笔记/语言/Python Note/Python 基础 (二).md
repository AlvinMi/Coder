# 函数式编程
> 这一节不太懂, 找时间补补。

##  高阶函数
既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。

学习 map/reduce/filter/sorted 这几个高阶函数。

高阶函数除了可以接收函数作为参数之外, 还能把函数作为结果值返回。


# 模块

在 Python 中, 一个 `.py` 就称之为一个模块。

使用模块的好处 :

* 提高了代码的可维护性, 不用重复造轮子, 写完一个模块后, 就能被其他地方引用了, 有很多 Python 内置的模块和第三方模块。
* 避免了函数名和变量名的冲突, 相同名字的函数和变量完全可以分别存在不同的模块中, 但是需要注意不要与 Python 内置的函数名冲突。在 Python 的官方文档中可以看到 [Python 内置的函数](https://docs.python.org/3/library/functions.html)。
* 那么如果模块与其他模块中间冲突了, Python 又引入了按目录来组织模块的方法, 称为包(Package)。有点要注意的是, 每个包目录下面都会又一个 `__init__.py` 的文件, 这个文件是必须的, 不然 Python 就只把这个目录当成一个普通的目录, 而不是一个包。 `__init__.py` 可以是空的, 也可以有 Python 代码。

> 创建模块时， 需要注意 Python 命名规范。 不要使用中文、特殊字符。不要和系统模块起冲突。

## 使用 模块

以内建的 `sys` 为例, 编写 一个 `hello` 模块。

```python
#!/usr/bin/env python3
#-*- coding: utf-8 -*-

'a test module' # 任何模块的第一个字符串都可以被视为 模块的文档注释

__author__ = 'alvinmi' # using study python3

import sys  # 导入该模块, 就能使用 sys 这个变量访问 sys 的所有模块。

def test():
    args = sys.argv
    if len(args)==1:
        print('Hello, world!')
    elif len(args)==2:
        print('Hello, %s!' % args[1])
    else:
        print('Too many arguments!')

# 学习到这儿, 在运行该 hello.py 模块的时候, Python 解释器吧一个特殊的变量, __name__ 置为 __main__ , 而如果在其他地方导入
# 该模块时, if 判断将失败, 所以 if 测试可以让一个模块通命令行运行时执行一些额外的代码, 最常见的就是运行测试。
if __name__=='__main__':    
    test()
```

### 作用域
一个模块中, 可能会定义很多函数和变量, 但有的函数和变量我们给别人使用, 有的函数仅仅在模块内部使用。 在 Python 中, 是通过 `_` 前缀来实现的。

正常的函数和变量名是公开的(public), 可以被直接引用, 比如 : `abc`, `x123`, `PI` 等, 类似 `__xxx__` 这样的变量是特殊变量, 可以被直接引用, 但是有特殊用途, 比如上面的 `__author__`, `__name__` 就是特殊变量, `hello` 模块定义的文档注释也可以用特殊变量 `__doc__` 访问, 我们自己的变量一般不要用这种变量名。

类似 `_xxx` 和 `__xxx` 这样的函数和变量就是非公开的 (private), **不应该** 被直接引用, 比如 : `_abc`, `__abc` 等。Python 中并没有一种方法可以完全限制访问 private 函数或者变量。

## 安装第三方模块
> Python 中, 通过包管理工具 pip 完成。

但是用 pip 一个个安装又费时费力, 那么就直接安装 Anaconda , 内置很多第三方库, 方便简单易用。 [Anaconda 下载](https://www.anaconda.com/download/#linux) 。 安装完成后可以在命令行交互式环境直接 import 。

添加自己的搜索目录 :

* 直接修改 `sys.path`, 添加需要搜索的目录 ：
```python
import sys
sys.path.append('/home/alvinmi/my_python_scripts')
```

* 设置环境变量.

# 面向对象编程
编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。

实例属性术语各个实例所有, 互不干扰。

类属性属于类所有, 所有实例共享一个属性。

# 面向对象高级编程
例如 多重继承、定制类、元类等概念。

## __slots__ 的使用




## 使用 @property

## 多重继承
## 定制类
## 使用枚举
## 使用元类
